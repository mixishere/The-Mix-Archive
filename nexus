(function() {
  const canvas = document.createElement("canvas");
  canvas.width = 1000;
  canvas.height = 700;
  
  const ctx = canvas.getContext("2d");
  const particles = [];
  const nodes = [];
  const edges = [];
  const trails = [];
  const waves = [];
  let selectedNode = null;
  let mouseX = 0;
  let mouseY = 0;
  let isDraggingNode = false;
  let isDrawingEdge = false;
  let edgeSourceNode = null;
  let frameCount = 0;
  let spawnRate = 0.4;
  let audioContext = null;
  let analyser = null;
  
  // Camera system
  const camera = {
    x: 0,
    y: 0,
    zoom: 1,
    panX: 0,
    panY: 0
  };
  
  // Preset modes
  let currentMode = "neural";
  const modes = ["neural", "solar", "fireworks"];
  
  Object.assign(canvas.style, {
    position: "fixed",
    top: "20px",
    left: "20px",
    cursor: "crosshair",
    background: "#0a0a0a",
    border: "2px solid #ff006e",
    boxShadow: "0 0 40px #ff006e88",
    zIndex: "99999"
  });
  
  document.body.appendChild(canvas);
  
  // Trail class
  class Trail {
    constructor(x, y, hue) {
      this.x = x;
      this.y = y;
      this.hue = hue;
      this.life = 40;
      this.maxLife = 40;
    }
    
    draw(ctx) {
      const alpha = (this.life / this.maxLife) * 0.4;
      ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${alpha})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
      ctx.fill();
      this.life--;
    }
  }
  
  // Wave class
  class Wave {
    constructor(x, y, hue) {
      this.x = x;
      this.y = y;
      this.hue = hue;
      this.radius = 0;
      this.life = 30;
    }
    
    draw(ctx) {
      const alpha = (this.life / 30) * 0.6;
      ctx.strokeStyle = `hsla(${this.hue}, 100%, 60%, ${alpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      this.radius += 3;
      this.life--;
    }
  }
  
  // Edge class
  class Edge {
    constructor(nodeA, nodeB) {
      this.nodeA = nodeA;
      this.nodeB = nodeB;
    }
    
    draw(ctx) {
      ctx.strokeStyle = "rgba(255, 0, 110, 0.3)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.nodeA.x, this.nodeA.y);
      ctx.lineTo(this.nodeB.x, this.nodeB.y);
      ctx.stroke();
    }
  }
  
  // Particle system
  class Particle {
    constructor(x, y, vx, vy, life, targetNode = null) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.life = life;
      this.maxLife = life;
      this.size = Math.random() * 3 + 1;
      this.targetNode = targetNode;
      this.hue = Math.random() * 360;
    }
    
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += 0.08;
      this.life--;
      
      // Gravity to target node
      if (this.targetNode) {
        const dx = this.targetNode.x - this.x;
        const dy = this.targetNode.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 10) {
          this.vx += (dx / dist) * 0.15;
          this.vy += (dy / dist) * 0.15;
        }
      }
    }
    
    draw(ctx) {
      const alpha = (this.life / this.maxLife) * 0.8;
      ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${alpha})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Interactive nodes
  class Node {
    constructor(x, y, label) {
      this.x = x;
      this.y = y;
      this.baseX = x;
      this.baseY = y;
      this.label = label;
      this.radius = 25;
      this.vx = (Math.random() - 0.5) * 2;
      this.vy = (Math.random() - 0.5) * 2;
      this.energy = 1;
      this.hue = Math.random() * 360;
      this.audioAmp = 0;
      this.trail = 0;
    }
    
    update() {
      const applyGravity = currentMode === "neural";
      
      if (!isDraggingNode || selectedNode !== this) {
        this.x += this.vx * (applyGravity ? 0.3 : 0.15);
        this.y += this.vy * (applyGravity ? 0.3 : 0.15);
        this.energy = Math.min(1, this.energy + 0.02);
        
        // Gravity to center (neural mode)
        if (applyGravity) {
          const dx = canvas.width / 2 - this.x;
          const dy = canvas.height / 2 - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 100) {
            this.vx += (dx / dist) * 0.05;
            this.vy += (dy / dist) * 0.05;
          }
        }
        
        // Inter-node gravity
        for (const other of nodes) {
          if (other !== this) {
            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 1;
            if (dist < 300) {
              this.vx += (dx / dist) * 0.02;
              this.vy += (dy / dist) * 0.02;
            }
          }
        }
      }
      
      // Bounce off edges
      if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
        this.vx *= -0.8;
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
      }
      if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
        this.vy *= -0.8;
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
      }
      
      // Trail
      if (this.trail-- <= 0) {
        trails.push(new Trail(this.x, this.y, this.hue));
        this.trail = 3;
      }
    }
    
    draw(ctx) {
      const glowSize = 20 + this.audioAmp * 30;
      ctx.fillStyle = `hsla(${this.hue}, 100%, ${50 + this.energy * 20}%, ${0.3 + this.audioAmp * 0.2})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = `hsl(${this.hue}, 100%, ${50 + this.energy * 20}%)`;
      ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
      ctx.shadowBlur = 20 + this.audioAmp * 10;
      
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = "#fff";
      ctx.font = "bold 10px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "transparent";
      ctx.fillText(this.label, this.x, this.y);
    }
    
    distanceTo(x, y) {
      const dx = this.x - x;
      const dy = this.y - y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }
  
  // Initialize nodes
  const nodeLabels = ["DATA", "PROCESS", "RENDER", "EMIT", "SYNC"];
  for (let i = 0; i < nodeLabels.length; i++) {
    const angle = (i / nodeLabels.length) * Math.PI * 2;
    const x = canvas.width / 2 + Math.cos(angle) * 150;
    const y = canvas.height / 2 + Math.sin(angle) * 150;
    nodes.push(new Node(x, y, nodeLabels[i]));
  }
  
  // Load state from localStorage
  function loadState() {
    const saved = localStorage.getItem("neural_state");
    if (saved) {
      const data = JSON.parse(saved);
      nodes.forEach((node, i) => {
        if (data.nodes[i]) {
          node.x = data.nodes[i].x;
          node.y = data.nodes[i].y;
          node.hue = data.nodes[i].hue;
        }
      });
      data.edges.forEach(([a, b]) => {
        edges.push(new Edge(nodes[a], nodes[b]));
      });
    }
  }
  
  // Save state to localStorage
  function saveState() {
    const state = {
      nodes: nodes.map(n => ({ x: n.x, y: n.y, hue: n.hue })),
      edges: edges.map(e => [nodes.indexOf(e.nodeA), nodes.indexOf(e.nodeB)])
    };
    localStorage.setItem("neural_state", JSON.stringify(state));
  }
  
  // Audio reactivity
  function initAudio() {
    if (audioContext) return;
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const mediaStream = navigator.mediaDevices.getUserMedia({ audio: true });
    mediaStream.then(stream => {
      const source = audioContext.createMediaStreamAudioSource(stream);
      analyser = audioContext.createAnalyser();
      source.connect(analyser);
      analyser.fftSize = 256;
    }).catch(() => console.log("Microphone not available"));
  }
  
  // Event handlers
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    
    if (isDraggingNode && selectedNode) {
      selectedNode.x = mouseX;
      selectedNode.y = mouseY;
    }
  });
  
  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Check if clicking on a node
    for (const node of nodes) {
      if (node.distanceTo(x, y) < node.radius * 1.5) {
        if (e.shiftKey) {
          // Delete node
          const idx = nodes.indexOf(node);
          nodes.splice(idx, 1);
          edges = edges.filter(e => e.nodeA !== node && e.nodeB !== node);
          saveState();
          return;
        }
        isDraggingNode = true;
        selectedNode = node;
        return;
      }
    }
    
    // Start edge drawing
    for (const node of nodes) {
      if (node.distanceTo(x, y) < node.radius * 2) {
        isDrawingEdge = true;
        edgeSourceNode = node;
        return;
      }
    }
  });
  
  canvas.addEventListener("mouseup", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    isDraggingNode = false;
    
    if (isDrawingEdge && edgeSourceNode) {
      for (const node of nodes) {
        if (node !== edgeSourceNode && node.distanceTo(x, y) < node.radius * 2) {
          edges.push(new Edge(edgeSourceNode, node));
          saveState();
          break;
        }
      }
      isDrawingEdge = false;
      edgeSourceNode = null;
    }
  });
  
  canvas.addEventListener("dblclick", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Create new node
    const label = String.fromCharCode(65 + Math.floor(Math.random() * 26));
    nodes.push(new Node(x, y, label));
    saveState();
  });
  
  canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (selectedNode) {
      selectedNode.vx = (Math.random() - 0.5) * 8;
      selectedNode.vy = (Math.random() - 0.5) * 8;
      selectedNode.energy = 0.3;
    }
  });
  
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    camera.zoom *= 1 - e.deltaY * 0.001;
    camera.zoom = Math.max(0.5, Math.min(3, camera.zoom));
  });
  
  // Keyboard control
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      selectedNode = null;
      particles.length = 0;
    }
    if (e.key === "m" || e.key === "M") {
      currentMode = modes[(modes.indexOf(currentMode) + 1) % modes.length];
    }
    if (e.key === "s" || e.key === "S") {
      saveState();
    }
    if (e.key === "l" || e.key === "L") {
      loadState();
    }
    if (e.key === "a" || e.key === "A") {
      initAudio();
    }
    if (e.key === "+") {
      spawnRate = Math.min(1, spawnRate + 0.1);
    }
    if (e.key === "-") {
      spawnRate = Math.max(0, spawnRate - 0.1);
    }
    if (e.key === "ArrowUp") {
      camera.panY += 20;
    }
    if (e.key === "ArrowDown") {
      camera.panY -= 20;
    }
    if (e.key === "ArrowLeft") {
      camera.panX += 20;
    }
    if (e.key === "ArrowRight") {
      camera.panX -= 20;
    }
  });
  
  // Animation loop
  function animate() {
    frameCount++;
    
    // Clear with fade
    ctx.fillStyle = "rgba(10, 10, 10, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-canvas.width / 2 + camera.panX, -canvas.height / 2 + camera.panY);
    
    // Audio reactivity
    if (analyser) {
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((a, b) => a + b) / dataArray.length / 255;
      nodes.forEach(n => n.audioAmp = avg);
    }
    
    // Draw edges
    edges.forEach(edge => edge.draw(ctx));
    
    // Draw trails
    for (let i = trails.length - 1; i >= 0; i--) {
      trails[i].draw(ctx);
      if (trails[i].life <= 0) trails.splice(i, 1);
    }
    
    // Draw waves
    for (let i = waves.length - 1; i >= 0; i--) {
      waves[i].draw(ctx);
      if (waves[i].life <= 0) waves.splice(i, 1);
    }
    
    // Update and draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      particles[i].draw(ctx);
      if (particles[i].life <= 0) particles.splice(i, 1);
    }
    
    // Update and draw nodes
    for (const node of nodes) {
      node.update();
      node.draw(ctx);
    }
    
    // Particle emission
    if (Math.random() < spawnRate) {
      const node = nodes[Math.floor(Math.random() * nodes.length)];
      if (node) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 2;
        particles.push(new Particle(
          node.x + Math.cos(angle) * node.radius,
          node.y + Math.sin(angle) * node.radius,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          60,
          edges.length > 0 ? nodes[Math.floor(Math.random() * nodes.length)] : null
        ));
      }
    }
    
    // Draw selection highlight
    if (selectedNode) {
      ctx.strokeStyle = `rgba(255, 200, 0, 0.8)`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(selectedNode.x, selectedNode.y, selectedNode.radius + 8, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Draw edge preview
    if (isDrawingEdge && edgeSourceNode) {
      ctx.strokeStyle = "rgba(255, 100, 150, 0.6)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(edgeSourceNode.x, edgeSourceNode.y);
      ctx.lineTo(mouseX, mouseY);
      ctx.stroke();
    }
    
    // Node collision detection
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dx = nodes[j].x - nodes[i].x;
        const dy = nodes[j].y - nodes[i].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < nodes[i].radius + nodes[j].radius) {
          waves.push(new Wave(nodes[i].x, nodes[i].y, nodes[i].hue));
          waves.push(new Wave(nodes[j].x, nodes[j].y, nodes[j].hue));
        }
      }
    }
    
    ctx.restore();
    
    // Draw HUD
    ctx.fillStyle = "rgba(255, 200, 0, 0.6)";
    ctx.font = "11px monospace";
    ctx.textAlign = "left";
    ctx.fillText(`FPS: ${Math.round(frameCount / (Date.now() / 1000))} | Particles: ${particles.length} | Mode: ${currentMode} | Spawn: ${spawnRate.toFixed(1)}`, 10, 20);
    ctx.fillText("[DCL] Node | [SHIFT+DCL] Delete | [DRAG] Connect | [WHEEL] Zoom | [M]ode | [S]ave | [L]oad | [A]udio | [+-] Spawn", 10, 35);
    
    requestAnimationFrame(animate);
  }
  
  loadState();
  animate();
})();
